<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Crossword Editor - Inbox Puzzles</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<style>
:root{
  --teal:#1f9dbf;
  --gold:#f5b041;
  --gray:#ddd;
  --bg:#fafafa;
  --cellSize:24px;
}
body{
  margin:0;
  font-family:Arial,Helvetica,sans-serif;
  background:var(--bg);
  color:#222;
}
.wrapper{
  max-width:1100px;
  margin:0 auto;
  padding:10px;
}
header{
  text-align:center;
  margin-bottom:10px;
}
h1{
  margin:.2em 0;
  color:var(--teal);
  font-size:1.6em;
}
h2{
  margin:.4em 0 .2em;
  font-size:1.1em;
  color:#444;
}
small{
  color:#666;
}
.controls{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin-bottom:10px;
}
.control-group{
  border:1px solid #ccc;
  border-radius:6px;
  padding:8px;
  background:#fff;
  flex:1 1 220px;
}
.control-group label{
  display:block;
  font-size:.9em;
  margin-bottom:3px;
}
.control-group input[type="text"]{
  width:100%;
  padding:4px;
  box-sizing:border-box;
}
button{
  padding:4px 8px;
  margin:2px 0;
  border-radius:4px;
  border:1px solid var(--teal);
  background:var(--teal);
  color:#fff;
  font-size:.85em;
}
button.secondary{
  background:#fff;
  color:var(--teal);
}
button.small{
  font-size:.75em;
  padding:3px 6px;
}
button.mode-toggle{
  border-radius:999px;
}
button.mode-active{
  background:var(--teal);
  color:#fff;
}
button.mode-inactive{
  background:#eee;
  color:#444;
  border-color:#bbb;
}
button.size-toggle{
  border-radius:999px;
  font-size:.8em;
}
button.size-active{
  background:var(--teal);
  color:#fff;
}
button.size-inactive{
  background:#f3f3f3;
  color:#444;
  border-color:#bbb;
}
.grid-container{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
}
.grid-wrapper{
  border:1px solid #ccc;
  border-radius:6px;
  padding:6px;
  background:#fff;
  max-width:100%;
}
.grid-scroll{
  overflow-x:auto;
}
#gridTable{
  border-collapse:collapse;
  margin:auto;
}
#gridTable td{
  width:var(--cellSize);
  height:var(--cellSize);
  border:1px solid var(--gray);
  padding:0;
  text-align:center;
  vertical-align:middle;
  font-size:14px;
  font-weight:bold;
  position:relative;
  background:#fff;
}
#gridTable td.block{
  background:var(--gold);
}
#gridTable td .num{
  position:absolute;
  top:1px;
  left:2px;
  font-size:8px;
  color:#222;
  font-weight:normal;
}
.clue-area{
  flex:1 1 260px;
}
textarea{
  width:100%;
  min-height:120px;
  box-sizing:border-box;
  font-size:.85em;
  font-family:monospace;
}
#combinedClues{
  min-height:80px;
}
#output{
  width:100%;
  min-height:180px;
  font-family:monospace;
  font-size:.8em;
  box-sizing:border-box;
}
.note{
  font-size:.8em;
  color:#555;
  margin-top:4px;
}
.rowcol-tools{
  display:flex;
  flex-wrap:wrap;
  gap:4px;
  align-items:center;
  font-size:.8em;
}
.rowcol-tools select{
  font-size:.8em;
  padding:2px;
}
.mode-row{
  margin-top:6px;
}
.mode-row span,
.size-row span{
  font-size:.8em;
  margin-right:4px;
}
.size-row{
  margin-bottom:6px;
}
@media(max-width:700px){
  #gridTable td{
    font-size:12px;
  }
  #gridTable td .num{
    font-size:7px;
  }
}
</style>
</head>
<body>
<div class="wrapper">
  <header>
    <h1>Crossword Editor – Inbox Puzzles</h1>
    <small>
      Choose grid size • tap/drag blocks • tap numbers in Number Mode • tap letters in Solution Mode • export JSON
    </small>
  </header>

  <div class="controls">
    <div class="control-group">
      <div class="size-row">
        <span>Grid size:</span>
        <button class="small size-toggle" data-size="15x15">15×15</button>
        <button class="small size-toggle" data-size="17x17">17×17</button>
        <button class="small size-toggle" data-size="19x19">19×19</button>
        <button class="small size-toggle" data-size="21x21">21×21</button>
      </div>
      <label>Title</label>
      <input type="text" id="titleInput" value="Daily Crossword">
      <label>Subtitle</label>
      <input type="text" id="subtitleInput" value="">
      <div class="note">
        For jumbo bonus puzzles you can use a subtitle like “Bonus Jumbo Puzzle” or theme name.
      </div>
    </div>

    <div class="control-group">
      <label>Grid & modes</label>
      <button id="clearGridBtn" class="small secondary">Clear all (white)</button>
      <button id="fillBlocksBtn" class="small secondary">Fill all (blocks)</button>
      <div class="rowcol-tools" style="margin-top:6px;">
        <span>Row:</span>
        <select id="rowSelect"></select>
        <button id="rowFillBtn" class="small secondary">Fill</button>
        <button id="rowClearBtn" class="small secondary">Clear</button>
        <button id="rowInvertBtn" class="small secondary">Invert</button>
      </div>
      <div class="rowcol-tools" style="margin-top:4px;">
        <span>Col:</span>
        <select id="colSelect"></select>
        <button id="colFillBtn" class="small secondary">Fill</button>
        <button id="colClearBtn" class="small secondary">Clear</button>
        <button id="colInvertBtn" class="small secondary">Invert</button>
      </div>
      <div class="mode-row">
        <span>Mode:</span>
        <button id="modeBlocks" class="small mode-toggle">Edit Blocks</button>
        <button id="modeNumbers" class="small mode-toggle">Edit Numbers</button>
        <button id="modeLetters" class="small mode-toggle">Edit Solution Letters</button>
      </div>
      <div class="note">
        • Edit Blocks: tap/drag to toggle gold/white.<br>
        • Edit Numbers: tap a white cell to enter/edit clue number.<br>
        • Edit Solution Letters: tap a white cell to enter/edit final answer letter.
      </div>
    </div>

    <div class="control-group">
      <label>Numbering & clues</label>
      <button id="autoNumberBtn" class="small">Auto-number grid</button>
      <button id="genSkeletonBtn" class="small secondary">Generate clue skeletons</button>
      <div class="note">
        Auto-number follows crossword rules. Skeletons fill the clue boxes with “3. ”, “4. ” etc.
      </div>
    </div>

    <div class="control-group">
      <label>Export</label>
      <button id="exportPuzzleBtn">Export Puzzle JSON</button>
      <button id="exportWithSolutionBtn" class="secondary">Export Puzzle + Solution</button>
      <div class="note">
        Exports include a <code>"solution"</code> array. Letters come from Solution Letter mode; blocks are <code>"#"</code>.
      </div>
    </div>
  </div>

  <div class="grid-container">
    <div class="grid-wrapper">
      <h2 id="gridTitle">Grid</h2>
      <div class="grid-scroll">
        <table id="gridTable"></table>
      </div>
    </div>

    <div class="clue-area">
      <h2>Across clues</h2>
      <textarea id="acrossText" placeholder="3. Light switch locale&#10;4. Handle on a door"></textarea>

      <h2>Down clues</h2>
      <textarea id="downText" placeholder="1. Cozy TV companion&#10;2. Not dirty&#10;4. Where the cook stirs things up&#10;5. Bedroom furniture for rest"></textarea>
    </div>
  </div>

  <h2>Optional: Paste combined clues to auto-separate</h2>
  <textarea id="combinedClues" placeholder="Across&#10;3. Light switch locale&#10;4. Handle on a door&#10;&#10;Down&#10;1. Cozy TV companion&#10;2. Not dirty&#10;4. Where the cook stirs things up&#10;5. Bedroom furniture for rest"></textarea>
  <button id="parseCluesBtn" class="small secondary">Parse combined clues → Across / Down</button>
  <div class="note">
    Lines starting with a number and a dot (e.g. <code>3.</code>) will be assigned to the current section (Across or Down).
  </div>

  <h2>Exported JSON</h2>
  <textarea id="output" readonly></textarea>
  <div class="note">
    Copy this JSON into <code>puzzle.json</code> in your puzzle folder. Your puzzle and solution pages will detect the grid size from <code>"rows"</code> and <code>"cols"</code>.
  </div>
</div>

<script>
let ROWS = 17;
let COLS = 17;

let grid = [];            // true = block, false = white
let numbers = [];         // integer or 0
let solutionLetters = []; // "" or "A"..."Z" for white cells
let editMode = 'blocks';  // 'blocks' | 'numbers' | 'letters'
let painting = false;
let paintToBlock = null;

const SIZE_PRESETS = {
  "15x15":[15,15],
  "17x17":[17,17],
  "19x19":[19,19],
  "21x21":[21,21]
};

function updateCellSize(){
  const w = window.innerWidth || 400;
  let size;
  if(COLS <= 17){
    // auto-fit, no scroll
    size = Math.floor((w * 0.9) / COLS);
    if(size > 32) size = 32;
    if(size < 18) size = 18;
  }else{
    // jumbo: keep readable, allow scroll if needed
    size = Math.floor((w * 0.9) / 19);
    if(size > 26) size = 26;
    if(size < 16) size = 16;
  }
  document.documentElement.style.setProperty('--cellSize', size + 'px');
}

function initData(){
  grid = [];
  numbers = [];
  solutionLetters = [];
  for(let r=0;r<ROWS;r++){
    const rowG = [];
    const rowN = [];
    const rowS = [];
    for(let c=0;c<COLS;c++){
      rowG.push(true);   // start all blocks
      rowN.push(0);
      rowS.push("");
    }
    grid.push(rowG);
    numbers.push(rowN);
    solutionLetters.push(rowS);
  }
}

function renderGrid(){
  updateCellSize();
  const table = document.getElementById('gridTable');
  table.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    const tr = document.createElement('tr');
    for(let c=0;c<COLS;c++){
      const td = document.createElement('td');
      td.dataset.row = r;
      td.dataset.col = c;

      if(grid[r][c]){
        td.classList.add('block');
      }

      const numVal = numbers[r][c];
      if(numVal){
        const numDiv = document.createElement('div');
        numDiv.className = 'num';
        numDiv.textContent = numVal;
        td.appendChild(numDiv);
      }

      if(!grid[r][c]){
        const letter = solutionLetters[r][c] || "";
        if(letter){
          td.appendChild(document.createTextNode(letter.toUpperCase()));
        }
      }

      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
  attachCellEvents();

  const gridTitle = document.getElementById('gridTitle');
  gridTitle.textContent = `Grid (${ROWS}×${COLS})`;
}

function setMode(mode){
  editMode = mode;
  const bBlocks = document.getElementById('modeBlocks');
  const bNums = document.getElementById('modeNumbers');
  const bLetters = document.getElementById('modeLetters');

  [bBlocks, bNums, bLetters].forEach(btn=>{
    btn.classList.remove('mode-active');
    btn.classList.add('mode-inactive');
  });

  if(mode==='blocks'){
    bBlocks.classList.add('mode-active');
    bBlocks.classList.remove('mode-inactive');
  }else if(mode==='numbers'){
    bNums.classList.add('mode-active');
    bNums.classList.remove('mode-inactive');
  }else if(mode==='letters'){
    bLetters.classList.add('mode-active');
    bLetters.classList.remove('mode-inactive');
  }
}

function attachCellEvents(){
  const table = document.getElementById('gridTable');
  const cells = table.querySelectorAll('td');

  cells.forEach(td => {
    td.onpointerdown = (e)=>{
      e.preventDefault();
      const r = parseInt(td.dataset.row,10);
      const c = parseInt(td.dataset.col,10);

      if(editMode === 'numbers'){
        editCellNumber(r,c);
        return;
      }

      if(editMode === 'letters'){
        editCellLetter(r,c);
        return;
      }

      // blocks mode
      painting = true;
      paintToBlock = !grid[r][c];
      applyPaint(td, r, c);
    };

    td.onpointerenter = (e)=>{
      if(!painting || editMode!=='blocks') return;
      e.preventDefault();
      const r = parseInt(td.dataset.row,10);
      const c = parseInt(td.dataset.col,10);
      applyPaint(td, r, c);
    };
  });

  document.onpointerup = ()=>{
    painting = false;
    paintToBlock = null;
  };
}

function applyPaint(td, r, c){
  grid[r][c] = paintToBlock;
  if(grid[r][c]){
    td.classList.add('block');
    numbers[r][c] = 0;
    solutionLetters[r][c] = "";
  }else{
    td.classList.remove('block');
  }
}

function editCellNumber(r,c){
  if(grid[r][c]) return;
  const current = numbers[r][c] ? String(numbers[r][c]) : '';
  const val = prompt('Enter clue number (blank to clear):', current);
  if(val === null) return;
  const trimmed = val.trim();
  if(trimmed === ''){
    numbers[r][c] = 0;
  }else{
    const n = parseInt(trimmed,10);
    if(isNaN(n) || n <= 0){
      numbers[r][c] = 0;
    }else{
      numbers[r][c] = n;
    }
  }
  renderGrid();
}

function editCellLetter(r,c){
  if(grid[r][c]) return;
  const current = solutionLetters[r][c] ? String(solutionLetters[r][c]) : '';
  const val = prompt('Enter solution letter (blank to clear):', current);
  if(val === null) return;
  const trimmed = val.trim().toUpperCase();
  if(trimmed === ''){
    solutionLetters[r][c] = "";
  }else{
    const m = trimmed.match(/[A-Z]/);
    if(m){
      solutionLetters[r][c] = m[0];
    }else{
      solutionLetters[r][c] = "";
    }
  }
  renderGrid();
}

function clearGrid(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      grid[r][c] = false;
      numbers[r][c] = 0;
      solutionLetters[r][c] = "";
    }
  }
  renderGrid();
}

function fillBlocks(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      grid[r][c] = true;
      numbers[r][c] = 0;
      solutionLetters[r][c] = "";
    }
  }
  renderGrid();
}

function rowOp(rowIndex, mode){
  for(let c=0;c<COLS;c++){
    if(mode==='fill') grid[rowIndex][c]=true;
    else if(mode==='clear') grid[rowIndex][c]=false;
    else if(mode==='invert') grid[rowIndex][c]=!grid[rowIndex][c];
    if(grid[rowIndex][c]){
      numbers[rowIndex][c]=0;
      solutionLetters[rowIndex][c]="";
    }
  }
  renderGrid();
}

function colOp(colIndex, mode){
  for(let r=0;r<ROWS;r++){
    if(mode==='fill') grid[r][colIndex]=true;
    else if(mode==='clear') grid[r][colIndex]=false;
    else if(mode==='invert') grid[r][colIndex]=!grid[r][colIndex];
    if(grid[r][colIndex]){
      numbers[r][colIndex]=0;
      solutionLetters[r][colIndex]="";
    }
  }
  renderGrid();
}

function autoNumber(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      numbers[r][c]=0;
    }
  }
  let current = 1;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(grid[r][c]) continue;
      const aboveBlock = (r===0) || grid[r-1][c];
      const leftBlock  = (c===0) || grid[r][c-1];
      if(aboveBlock || leftBlock){
        numbers[r][c] = current++;
      }
    }
  }
  renderGrid();
}

function generateClueSkeletons(){
  const acrossNums = [];
  const downNums = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(grid[r][c]) continue;
      const num = numbers[r][c];
      if(!num) continue;
      const isStartAcross = (c===0 || grid[r][c-1]===true) && (c+1<COLS && grid[r][c+1]===false);
      const isStartDown   = (r===0 || grid[r-1][c]===true) && (r+1<ROWS && grid[r+1][c]===false);
      if(isStartAcross) acrossNums.push(num);
      if(isStartDown) downNums.push(num);
    }
  }
  const acrossBox = document.getElementById('acrossText');
  const downBox = document.getElementById('downText');
  acrossBox.value = acrossNums.map(n=>`${n}. `).join('\n');
  downBox.value = downNums.map(n=>`${n}. `).join('\n');
}

function parseCombinedClues(){
  const raw = document.getElementById('combinedClues').value;
  const lines = raw.split(/\r?\n/);
  let section = null;
  const acrossLines = [];
  const downLines = [];
  for(let line of lines){
    const trimmed = line.trim();
    if(!trimmed) continue;
    const lower = trimmed.toLowerCase();
    if(lower==='across'){
      section = 'across';
      continue;
    }
    if(lower==='down'){
      section = 'down';
      continue;
    }
    const m = trimmed.match(/^(\d+)\.\s*(.*)$/);
    if(m && section){
      if(section==='across') acrossLines.push(trimmed);
      else if(section==='down') downLines.push(trimmed);
    }
  }
  document.getElementById('acrossText').value = acrossLines.join('\n');
  document.getElementById('downText').value = downLines.join('\n');
}

function buildClueObjects(){
  const acrossObj = {};
  const downObj = {};
  const acrossText = document.getElementById('acrossText').value.split(/\r?\n/);
  const downText = document.getElementById('downText').value.split(/\r?\n/);

  for(let line of acrossText){
    const trimmed = line.trim();
    if(!trimmed) continue;
    const m = trimmed.match(/^(\d+)\.\s*(.*)$/);
    if(m){
      const num = m[1];
      const clue = m[2] || '';
      acrossObj[num] = clue;
    }
  }

  for(let line of downText){
    const trimmed = line.trim();
    if(!trimmed) continue;
    const m = trimmed.match(/^(\d+)\.\s*(.*)$/);
    if(m){
      const num = m[1];
      const clue = m[2] || '';
      downObj[num] = clue;
    }
  }
  return { acrossObj, downObj };
}

function exportJson(includeSolution){
  const title = document.getElementById('titleInput').value || 'Daily Crossword';
  const subtitle = document.getElementById('subtitleInput').value || '';

  const {acrossObj, downObj} = buildClueObjects();

  const gridChars = [];
  for(let r=0;r<ROWS;r++){
    const row = [];
    for(let c=0;c<COLS;c++){
      row.push(grid[r][c] ? "#" : "");
    }
    gridChars.push(row);
  }

  const solution = [];
  if(includeSolution){
    for(let r=0;r<ROWS;r++){
      const row = [];
      for(let c=0;c<COLS;c++){
        if(grid[r][c]){
          row.push("#");
        }else{
          const letter = solutionLetters[r][c] || "";
          row.push(letter);
        }
      }
      solution.push(row);
    }
  }

  const obj = {
    title:title,
    subtitle:subtitle,
    rows:ROWS,
    cols:COLS,
    grid:gridChars,
    numbers:numbers,
    across:acrossObj,
    down:downObj
  };
  if(includeSolution){
    obj.solution = solution;
  }

  const out = JSON.stringify(obj,null,2);
  document.getElementById('output').value = out;
}

function setGridSize(rows, cols){
  ROWS = rows;
  COLS = cols;
  initData();
  populateRowColSelectors();
  renderGrid();
  updateSizeButtons();
}

function updateSizeButtons(){
  const buttons = document.querySelectorAll('.size-toggle');
  buttons.forEach(btn=>{
    btn.classList.remove('size-active');
    btn.classList.add('size-inactive');
    const sz = btn.getAttribute('data-size');
    const pair = SIZE_PRESETS[sz];
    if(pair && pair[0]===ROWS && pair[1]===COLS){
      btn.classList.add('size-active');
      btn.classList.remove('size-inactive');
    }
  });
}

function populateRowColSelectors(){
  const rowSel = document.getElementById('rowSelect');
  const colSel = document.getElementById('colSelect');
  rowSel.innerHTML = '';
  colSel.innerHTML = '';
  for(let i=1;i<=ROWS;i++){
    const o = document.createElement('option');
    o.value = i-1;
    o.textContent = i;
    rowSel.appendChild(o);
  }
  for(let i=1;i<=COLS;i++){
    const o = document.createElement('option');
    o.value = i-1;
    o.textContent = i;
    colSel.appendChild(o);
  }
}

// INIT
(function(){
  // default to 17x17 for your daily puzzles
  ROWS = 17;
  COLS = 17;
  initData();
  populateRowColSelectors();
  renderGrid();
  setMode('blocks');
  updateSizeButtons();

  document.getElementById('clearGridBtn').onclick = clearGrid;
  document.getElementById('fillBlocksBtn').onclick = fillBlocks;

  document.getElementById('rowFillBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('rowSelect').value,10);
    rowOp(idx,'fill');
  };
  document.getElementById('rowClearBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('rowSelect').value,10);
    rowOp(idx,'clear');
  };
  document.getElementById('rowInvertBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('rowSelect').value,10);
    rowOp(idx,'invert');
  };

  document.getElementById('colFillBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('colSelect').value,10);
    colOp(idx,'fill');
  };
  document.getElementById('colClearBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('colSelect').value,10);
    colOp(idx,'clear');
  };
  document.getElementById('colInvertBtn').onclick = ()=>{
    const idx = parseInt(document.getElementById('colSelect').value,10);
    colOp(idx,'invert');
  };

  document.getElementById('autoNumberBtn').onclick = autoNumber;
  document.getElementById('genSkeletonBtn').onclick = generateClueSkeletons;
  document.getElementById('parseCluesBtn').onclick = parseCombinedClues;

  document.getElementById('exportPuzzleBtn').onclick = ()=>exportJson(true);
  document.getElementById('exportWithSolutionBtn').onclick = ()=>exportJson(true);

  document.getElementById('modeBlocks').onclick = ()=>setMode('blocks');
  document.getElementById('modeNumbers').onclick = ()=>setMode('numbers');
  document.getElementById('modeLetters').onclick = ()=>setMode('letters');

  const sizeButtons = document.querySelectorAll('.size-toggle');
  sizeButtons.forEach(btn=>{
    btn.onclick = ()=>{
      const sz = btn.getAttribute('data-size');
      const pair = SIZE_PRESETS[sz];
      if(pair){
        setGridSize(pair[0], pair[1]);
      }
    };
  });

  window.addEventListener('resize', ()=>{
    updateCellSize();
  });
})();
</script>
</body>
</html>
